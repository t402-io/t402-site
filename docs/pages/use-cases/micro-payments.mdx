# Micro-Payments

Enable sub-cent payments for data, compute, or any digital resource. T402 + Layer 2 networks make true micro-payments economically viable.

## Why Micro-Payments?

Traditional payment systems can't handle small amounts:

| Payment Method | Minimum Viable Payment |
|----------------|----------------------|
| Credit Cards | ~$0.50 (due to fees) |
| PayPal | ~$0.30 (due to fees) |
| Stripe | ~$0.50 (due to fees) |
| **T402 on Base** | **~$0.0001** |

With T402 on L2 networks, you can profitably charge fractions of a cent.

## Network Selection for Micro-Payments

Choose the right network based on payment size:

| Payment Size | Recommended Network | Gas Cost |
|--------------|--------------------:|----------|
| $0.0001 - $0.001 | Base (gasless) | ~$0 |
| $0.001 - $0.01 | Base, Arbitrum | ~$0.001 |
| $0.01 - $0.10 | Any EVM | ~$0.01 |
| $0.10+ | Any supported | Varies |

## Gasless Micro-Payments

For the smallest payments, use ERC-4337 gasless transactions:

```typescript
import { GaslessT402Client } from '@t402/wdk-gasless'

const client = new GaslessT402Client({
  bundlerUrl: 'https://bundler.example.com',
  paymasterUrl: 'https://paymaster.example.com',
  network: 'eip155:8453'
})

// Users pay $0.001 without needing gas
await client.pay({
  to: '0xMerchant...',
  amount: '0.001',
  asset: 'USDT'
})
```

## Use Cases

### Per-API-Call Pricing

```typescript
// Charge $0.0001 per API call
'GET /api/data': {
  price: '$0.0001',
  network: 'eip155:8453',
  payTo: process.env.WALLET_ADDRESS
}
```

### Per-Token Pricing (AI/LLM)

```typescript
// Charge based on token usage
'POST /api/generate': {
  price: (req) => {
    const tokens = estimateTokens(req.body.prompt)
    const pricePerToken = 0.00001 // $0.00001 per token
    return `$${tokens * pricePerToken}`
  },
  network: 'eip155:8453',
  payTo: process.env.WALLET_ADDRESS
}
```

### Per-Byte Pricing (Storage/Bandwidth)

```typescript
// Charge based on data size
'POST /api/upload': {
  price: (req) => {
    const bytes = parseInt(req.headers['content-length'])
    const pricePerMB = 0.001 // $0.001 per MB
    const priceInDollars = (bytes / 1024 / 1024) * pricePerMB
    return `$${priceInDollars.toFixed(6)}`
  },
  network: 'eip155:8453',
  payTo: process.env.WALLET_ADDRESS
}
```

### Per-Second Pricing (Compute)

```typescript
// Charge for compute time
'POST /api/render': {
  price: (req) => {
    const estimatedSeconds = estimateRenderTime(req.body)
    const pricePerSecond = 0.01 // $0.01 per second
    return `$${estimatedSeconds * pricePerSecond}`
  },
  network: 'eip155:8453',
  payTo: process.env.WALLET_ADDRESS
}
```

## Batching for Efficiency

For very high-volume micro-payments, batch multiple payments:

```typescript
import { BatchPaymentClient } from '@t402/core'

const client = new BatchPaymentClient({
  network: 'eip155:8453',
  batchInterval: 60000, // Batch every minute
  minBatchSize: 10
})

// Individual payments are batched automatically
await client.queuePayment({ to: merchant1, amount: '0.001' })
await client.queuePayment({ to: merchant2, amount: '0.002' })
// ... payments are settled together
```

## Pricing Calculator

Use this formula to determine if micro-payments are viable:

```
Net Revenue = Payment Amount - Network Fee

For Base (L2):
- Network fee: ~$0.001
- Minimum viable payment: ~$0.002 (50% margin)

For Ethereum (L1):
- Network fee: ~$1-5
- Minimum viable payment: ~$2-10
```

import { Callout } from 'nextra/components'

<Callout type="warning">
**Always test on testnet first!** Network fees vary with congestion.
</Callout>

## Implementation Tips

### 1. Use L2 Networks

Always use Layer 2 for micro-payments:

```typescript
const MICRO_PAYMENT_NETWORKS = [
  'eip155:8453',   // Base
  'eip155:42161',  // Arbitrum
  'eip155:10',     // Optimism
]
```

### 2. Implement Caching

Cache payment authorizations to reduce blockchain calls:

```typescript
const paymentCache = new Map()

function getCachedPayment(userId, resource) {
  const key = `${userId}:${resource}`
  const cached = paymentCache.get(key)
  if (cached && cached.expiresAt > Date.now()) {
    return cached.payment
  }
  return null
}
```

### 3. Aggregate Small Payments

For very small payments, consider aggregation:

```typescript
// Track usage, settle periodically
let userBalance = {}

function trackUsage(userId, amount) {
  userBalance[userId] = (userBalance[userId] || 0) + amount
}

// Settle when balance exceeds threshold
function settleIfNeeded(userId) {
  if (userBalance[userId] >= 0.01) { // $0.01 minimum
    settlePayment(userId, userBalance[userId])
    userBalance[userId] = 0
  }
}
```

## Comparison with Other Systems

| Feature | T402 | Lightning Network | Stripe |
|---------|------|-------------------|--------|
| Min Payment | $0.0001 | $0.00001 | $0.50 |
| Settlement | Instant | Instant | 2-7 days |
| Currency | USDT | BTC | Fiat |
| Integration | HTTP | Custom protocol | API |

## Next Steps

- [Gasless Payments](/advanced/gasless) - Zero-gas user experience
- [API Monetization](/use-cases/api-monetization) - Build paid APIs
- [EVM Reference](/reference/evm) - EVM SDK documentation
